Кто такой граф
==============
Введём следующие обозначения: **V - число вершин графа**, **E - множество рёбер** - объектов вида {node_from, node_to}

Граф может быть **ориентированным** (у всех рёбер есть направление, идут от вершины node_from в вершину node_to) и **неориентированным** (у рёбер нет направление или можно считать, что для любого ребра {node_from, node_to} существует обратное {node_to, node_from}).

Также важными понятиями в теории графов являются циклы (то есть такие пути по рёбрам, что они начинаются и заканчиваются в одной вершине) и петли (то есть рёбра из вершины в саму себя).

Виды графов
===========
- Плотные: E ~ V^2 - рёбер много
- Разреженные E ~ V - ребёр примерно столько же, сколько вершин

Представление графа
===================
- **Матрица смежности** - табличка VxV, где в (i, j) ячейке стоит
	а) 1 если есть ребро (i, j), 0 - если такое ребро отсутствует;
	б) иногда вместо а) в ячейке лежит вес ребра (i, j) или признак отсутствия ребра, оговоренный в условии.
  
  Обход такой матрицы занимает O(v^2), узнать, существует ли ребро (i, j) - O(1), обойти соседей вершины - O(v).
  
  Из-за последнего пункта почти никто такие матрицы не использует, потому что в алгоритмах мы часто хотим смотреть на всех соседей, а в данном случае это плохо.

  Реализация:
  ```
  std::vector<std::vector<int>> matrix;
  matrix[i][j] // наличие ребра из i в j
  for (v : matrix[i]):
    do_sth; // обход потенциальных соседей
  ```


- **Списки смежности** - список из V подсписков, где в каждом i-ом подсписке перечислены соседи вершины i. Однако наиболее часто реализуется в виде списка map-ов или просто огромного map-а, что позволяет быстро выяснять наличие соседа у вершины. Обход списка смежности занимает O(V + E), узнать, существует ли ребро (i, j) - O(log(v)), обойти соседей вершины - O(v), но в отличие от матриц смежности на разреженных графах это работает лучше.

  Списки смежности намного эффективнее в случае разреженных графов.

  Реализация будет приведена далее в коде графа.
