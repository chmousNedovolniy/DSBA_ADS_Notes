Здесь постарался собрать всё полезное для заспойлеренных тем на КР, а именно

Код
===
- [Шаблон класса Graph от семинариста и пример обработки входных данных](graph_and_input.cpp)
- [Обзор функций класса Graph](graph_func_review.cpp)
- [Вспомогательный класс приоритетной очереди (нужен для Дейкстры)](priority_queue.cpp)
- [**Алгоритм Дейкстры** для поиска кратчайших путей от одной вершины для всех других (только для графов с неотрицательными весами рёбер)](dijkstra.cpp)
- [**Восстановление кратчайшего пути** между вершинами с помощью Дейкстры](dijkstra.cpp)
- [**Алгоритм Беллмана-Форда** для поиска кратчайших путей от одной вершины для всех других](bellman-ford.cpp)
- [**Алгоритм Флойда-Уоршелла** для поиска кратчайших путей между всеми парами вершин](floyd.cpp)
- [Обнаружение **отрицательных циклов** в графе](negative_cycles.cpp)
- Нахождение **путей максимальной длины** (а не кратчайшей)
    - Необходимо, чтобы в графе не было циклов положительного веса, иначе всему смэрть (мы можем бесконечно увеличивать расстояния)
    - В случае неотрицательных ребёр достаточно умножить все веса рёбер на -1 и запустить алгоритм дейкстры с начальной distance = INT_MIN/2 вместо INT_MAX/2. Тогда алгоритм найдёт самые короткие пути (они будут отрицательными, но при этом по модулю самыми большими). Останется только домножить каждый полученный результат на -1, чтобы вернуться к исходным длинам. Полученные длины будут максимальными.
    - В случае графа с отрицательными весами рёбер оптимальным решением будет повеситься (или погуглить, потому что я не знаю, ыы)

Презентации с семинаров по темам
================================
- [Алгоритм Дейкстры](slides/dijkstra.pdf)
- [Алгоритм Флойда-Уоршелла](slides/floyd.pdf)
- [Алгоритм Беллмана-Форда и поиск отрицательных циклов](slides/bellman-ford.pdf)

Примечания
----------
1. Везде, где используются обозначения MyGraph или Node, подразумевается, что после кода графа написано
```
using MyGraph = Graph<int>; // or Graph<std::string>
using Node = Graph<int>::Node; // or Graph<std::string>::Node
// or any other type in <> actually
```
