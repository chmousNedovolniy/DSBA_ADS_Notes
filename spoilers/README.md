UPD:
---
Small notes:
1. Don't use INT_MAX, use sth like const int inf = 1e9; (I've fixed it in Dijkstra.cpp file in repo)
2. No float results in decreasing, you can just do / 2 with integers;
3. Pay attention to BUT part of agreement

Здесь постарался собрать всё полезное для заспойлеренных тем на КР, а именно

Код
===
- [Шаблон класса Graph от семинариста и пример обработки входных данных](graph_and_input.cpp)
- [Обзор функций класса Graph](graph_func_review.cpp)
- [Вспомогательный класс приоритетной очереди (нужен для Дейкстры)](priority_queue.cpp)
- [**Алгоритм Дейкстры** для поиска кратчайших путей от одной вершины для всех других (только для графов с неотрицательными весами рёбер)](dijkstra.cpp)
- [**Восстановление кратчайшего пути** между вершинами с помощью Дейкстры](dijkstra.cpp)
- [**Алгоритм Беллмана-Форда** для поиска кратчайших путей от одной вершины для всех других](bellman-ford.cpp)
- [**Алгоритм Флойда-Уоршелла** для поиска кратчайших путей между всеми парами вершин](floyd.cpp)
- [Обнаружение **отрицательных циклов** в графе](negative_cycles.cpp)
- Нахождение **путей максимальной длины** (а не кратчайшей)
    - Здесь мне неочевидны некоторые проблемы, поэтому стоит спросить у семинариста

Презентации с семинаров по темам
================================
- [Алгоритм Дейкстры](slides/dijkstra.pdf)
- [Алгоритм Флойда-Уоршелла](slides/floyd.pdf)
- [Алгоритм Беллмана-Форда и поиск отрицательных циклов](slides/bellman-ford.pdf)

Примечания
----------
1. Везде, где используются обозначения MyGraph или Node, подразумевается, что после кода графа написано
```
using MyGraph = Graph<int>; // or Graph<std::string>
using Node = Graph<int>::Node; // or Graph<std::string>::Node
// or any other type in <> actually
```
2. Аккуратно выставляйте значение, принимаемое за бесконечность. В моем коде это часто INT_MAX или INT_MAX / 2, однако на самом деле нам нужно значение, которое будет больше любого пути в графе. В целом можно взять что-то типа edge_count * max_edge_length + 1. Такое значение может не поместиться в int, так что часто стоит расстояния считать  в lont long. Также стоит следить за переполнениями, если вы вдруг складываете две бесконечности (INT_MAX + INT_MAX, например, не дадут ничего хорошего), что также намекает на разумность использования long long.
