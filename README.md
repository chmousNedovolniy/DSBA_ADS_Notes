# DSBA_ADS_Notes
Hope it helps a bit for the upcoming test

- В [basics.md](basics.md) лежит описание базовых терминов и способов хранения графа
- [graph.cpp](graph.cpp) - верный помощник, копипастишь себе, пользуешься
- [basic_review.cpp](basic_review.cpp) - обзор функций класса выше

В папках лежат некоторые [материалы с семинаров](seminars) и мои немного обработанные [заметки](my_helpers), которыми также можно пользоваться. Они являются переработкой материалов с семинаров в более удобоваримой форме.

Самая важная часть лежит в [spoilers](spoilers), там все материалы по поиску кратчайших путей в графе (как раз то, что будет на кр)

Записи консультации
- [Часть 1](https://disk.yandex.ru/i/iGm85fjahLudAA) 
- [Часть 2](https://disk.yandex.ru/i/C4XB4fRL_waf_A)


(Копипаста описания spoilers для удобства пользования):
Здесь постарался собрать всё полезное для заспойлеренных тем на КР, а именно

Код
===
- [Шаблон класса Graph от семинариста и пример обработки входных данных](spoilers/graph_and_input.cpp)
- [Обзор функций класса Graph](spoilers/graph_func_review.cpp)
- [Вспомогательный класс приоритетной очереди (нужен для Дейкстры)](spoilers/priority_queue.cpp)
- [**Алгоритм Дейкстры** для поиска кратчайших путей от одной вершины для всех других (только для графов с неотрицательными весами рёбер)](spoilers/dijkstra.cpp)
- [**Восстановление кратчайшего пути** между вершинами с помощью Дейкстры](spoilers/dijkstra.cpp)
- [**Алгоритм Беллмана-Форда** для поиска кратчайших путей от одной вершины для всех других](spoilers/bellman-ford.cpp)
- [**Алгоритм Флойда-Уоршелла** для поиска кратчайших путей между всеми парами вершин](spoilers/floyd.cpp)
- [Обнаружение **отрицательных циклов** в графе](spoilers/negative_cycles.cpp)
- Нахождение **путей максимальной длины** (а не кратчайшей)
    - Здесь мне неочевидны некоторые проблемы, поэтому стоит спросить у семинариста

Презентации с семинаров по темам
================================
- [Алгоритм Дейкстры](spoilers/slides/dijkstra.pdf)
- [Алгоритм Флойда-Уоршелла](spoilers/slides/floyd.pdf)
- [Алгоритм Беллмана-Форда и поиск отрицательных циклов](spoilers/slides/bellman-ford.pdf)

Примечания
----------
1. Везде, где используются обозначения MyGraph или Node, подразумевается, что после кода графа написано
```
using MyGraph = Graph<int>; // or Graph<std::string>
using Node = Graph<int>::Node; // or Graph<std::string>::Node
// or any other type in <> actually
```
2. Аккуратно выставляйте значение, принимаемое за бесконечность. В моем коде это часто INT_MAX или INT_MAX / 2, однако на самом деле нам нужно значение, которое будет больше любого пути в графе. В целом можно взять что-то типа edge_count * max_edge_length + 1. Такое значение может не поместиться в int, так что часто стоит расстояния считать  в lont long. Также стоит следить за переполнениями, если вы вдруг складываете две бесконечности (INT_MAX + INT_MAX, например, не дадут ничего хорошего), что также намекает на разумность использования long long.
